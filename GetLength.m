function [capacity] = GetLength(data, direction, win, noise)
%Визначення необхідної ємності для опису крайової функції
% data - частина даних зображення
% win - ширина вікна
% noise - значення шуму у %, яке варто відсікти
% direction - напрямок визначення функції розсіювання лінії
% 1 / H - горизонтально
% 2 / V - вертикально

% for warning
str = 'Input format of component is failed.';

% change unit of direction
if ischar(direction)
    if (upper(direction) == 'H')
        direction = 1;
    elseif (upper(direction) == 'V')
        direction = 2;
    else
        warning(str);
        return;
    end
elseif ~isnumeric(direction)
    warning(str);
    return;
end

% lines - кількість краєвих ліній для аналізу 
% count - кількість точок з якими описується крайова функція
if (direction == 1)
    [lines, count] = size(data);
else
    [count, lines] = size(data);
end

% змінна для відфільтрованих даних
dataAverage = zeros(size(data, 1), size(data, 2));
capacity = zeros(lines, 1);

% фільтрація даних - усереднення з шириною вікна win
if (direction == 1)
    for i = 1 : lines
        line = double(data(i, :));
       
        % розраховуємо відхилення, для виявлення сходинки - суттєвого
        % перепаду інтенсивності, і саме суттєвий перепад інтенсивності в
        % заданому вікні визначатиме розміри ESF
        for j = 1 : count
            dataAverage(i, j) = std(GetWinArray(line, win, j), 1);
        end
        
        line = dataAverage(i, :);
        
        % якщо шум становить 5% від максималного значення, (величину задає користувач)
        lim = noise * max(line) / 100;
    
        % нормування значень, якщо відхилення незначні то 0, а якщо перепад
        % більше вкащаного значення шуму, то 1
        line = line >= lim;
        
        % визначення кількості необхідних точок для опису крафової функції
        capacity(i) = sum(line);
    end
else
    for i = 1 : lines
        line = double(data(:, i));
       
        % розраховуємо відхилення, для виявлення сходинки - суттєвого
        % перепаду інтенсивності, і саме суттєвий перепад інтенсивності в
        % заданому вікні визначатиме розміри ESF
        for j = 1 : count
            dataAverage(j, i) = std(GetWinArray(line, win, j), 1);
        end
        
        line = dataAverage(:, i);
        
        % якщо шум становить 5% від максималного значення, (величину задає користувач)
        lim = noise * max(line) / 100;
    
        % нормування значень, якщо відхилення незначні то 0, а якщо перепад
        % більше вкащаного значення шуму, то 1
        line = line >= lim;
        
        % визначення кількості необхідних точок для опису крафової функції
        capacity(i) = sum(line);
    end
end

% Примітка. Звичайно, деякі занчення можуть виходити за межі перепаду і в
% результаті ці значення враховуються в загальну картину; тобто щоб
% притримуватися точності як такої необхідно збільшувати розмір вікна і
% значення шуму, але це еквівалентно простому заданню того ж вікна і нічим
% не відрізняється, а в даному випадку при низькому шумі воно видає більш
% ширше вікно для опису крайової функції; Причому це впливаэ лише на
% величину вибірки даних, а не на МПФ

% вибираємо максимальне значення
capacity = max(capacity);

end

